# Purpose: Flask Blueprint for managing autogenerated data exception tickets.
# Provides routes for viewing, assigning, and clearing tickets with full audit trail.

from flask import (
    Blueprint,
    render_template,
    request,
    redirect,
    url_for,
    flash,
    current_app,
    jsonify,
)
from analytics import ticket_processing
import pandas as pd
from datetime import datetime
import os
from typing import List
import logging

ticket_bp = Blueprint("ticket_bp", __name__, template_folder="../templates")

logger = logging.getLogger(__name__)


def load_users(data_folder_path: str) -> List[str]:
    """Load the list of users from users.csv for the dropdown."""
    users_file_path = os.path.join(data_folder_path, "users.csv")
    try:
        if os.path.exists(users_file_path):
            df = pd.read_csv(users_file_path)
            if "Name" in df.columns:
                users = df["Name"].dropna().astype(str).tolist()
                return sorted(users)
            else:
                logger.warning("'Name' column not found in users.csv.")
                return []
        else:
            logger.warning(f"users.csv not found at {users_file_path}.")
            return []
    except Exception as e:
        logger.error(f"Error loading users from {users_file_path}: {e}")
        return []


@ticket_bp.route("/tickets", methods=["GET", "POST"])
def manage_tickets():
    """Main ticket management page with filtering, bulk operations, and user assignment."""
    data_folder = current_app.config["DATA_FOLDER"]
    
    try:
        if request.method == "POST":
            action = request.form.get("action")
            
            # Handle bulk operations
            if action == "bulk_assign":
                selected_tickets = request.form.getlist("selected_tickets")
                assigned_to = request.form.get("bulk_assigned_to")
                if assigned_to and selected_tickets:
                    success_count, total_count = ticket_processing.bulk_assign_tickets(selected_tickets, assigned_to, data_folder)
                    flash(f"Successfully assigned {success_count}/{total_count} tickets to {assigned_to}", "success")
                else:
                    flash("Missing user or no tickets selected", "error")
            
            elif action == "bulk_clear":
                selected_tickets = request.form.getlist("selected_tickets")
                cleared_by = request.form.get("bulk_cleared_by")
                clearance_reason = request.form.get("bulk_clearance_reason")
                if cleared_by and clearance_reason and selected_tickets:
                    success_count, total_count = ticket_processing.bulk_clear_tickets(selected_tickets, cleared_by, clearance_reason, data_folder)
                    flash(f"Successfully cleared {success_count}/{total_count} tickets", "success")
                else:
                    flash("Missing required fields or no tickets selected", "error")
            
            elif action == "bulk_retest":
                selected_tickets = request.form.getlist("selected_tickets")
                if selected_tickets:
                    success_count, total_count = ticket_processing.bulk_retest_tickets(selected_tickets, data_folder)
                    flash(f"Marked {success_count}/{total_count} tickets for retest", "success" if success_count else "error")
                else:
                    flash("No tickets selected for retest", "error")
            
            # Redirect to avoid resubmission
            return redirect(url_for("ticket_bp.manage_tickets"))
        
        # Handle GET request with filters
        source_filter = request.args.get("source_filter", "All")
        status_filter = request.args.get("status_filter", "All") 
        entity_filter = request.args.get("entity_filter", "")
        assigned_to_filter = request.args.get("assigned_to_filter", "All")
        selected_user = request.args.get("user", "")
        
        users = load_users(data_folder)
        if not selected_user and users:
            selected_user = users[0]
        
        # Load tickets with filters applied
        tickets_df = ticket_processing.get_tickets_by_filters(
            data_folder,
            source_filter=source_filter if source_filter != "All" else None,
            status_filter=status_filter if status_filter != "All" else None,
            entity_filter=entity_filter if entity_filter else None,
            assigned_to_filter=assigned_to_filter if assigned_to_filter != "All" else None
        )
        
        # Get all tickets for filter options
        all_tickets_df = ticket_processing.load_tickets(data_folder)
        available_sources = sorted(all_tickets_df["SourceCheck"].unique()) if not all_tickets_df.empty else []
        available_assignees = sorted(all_tickets_df["AssignedTo"].dropna().unique()) if not all_tickets_df.empty else []
        
        # Group filtered tickets by status
        unallocated_tickets = tickets_df[tickets_df["Status"] == "Unallocated"].to_dict("records")
        waiting_rerun_tickets = tickets_df[tickets_df["Status"] == "WaitingRerun"].to_dict("records")
        assigned_tickets = tickets_df[tickets_df["Status"] == "Assigned"].to_dict("records")
        cleared_tickets = tickets_df[tickets_df["Status"] == "Cleared"].to_dict("records")
        
        # User's personal tickets
        my_tickets = []
        if selected_user:
            my_tickets = [t for t in assigned_tickets if t["AssignedTo"] == selected_user]
        
        # Sort tickets by generation date (newest first)
        for ticket_list in [unallocated_tickets, waiting_rerun_tickets, assigned_tickets, cleared_tickets, my_tickets]:
            ticket_list.sort(key=lambda x: x["GenerationDate"], reverse=True)
        
        return render_template(
            "tickets_page.html",
            unallocated_tickets=unallocated_tickets,
            waiting_rerun_tickets=waiting_rerun_tickets,
            assigned_tickets=assigned_tickets,
            cleared_tickets=cleared_tickets,
            my_tickets=my_tickets,
            users=users,
            selected_user=selected_user,
            available_sources=available_sources,
            available_assignees=available_assignees,
            current_filters={
                "source_filter": source_filter,
                "status_filter": status_filter,
                "entity_filter": entity_filter,
                "assigned_to_filter": assigned_to_filter,
            }
        )
        
    except Exception as e:
        logger.error(f"Error loading tickets page: {e}", exc_info=True)
        flash("Error loading tickets page", "error")
        return redirect(url_for("main.index"))


@ticket_bp.route("/tickets/assign/<ticket_id>", methods=["POST"])
def assign_ticket(ticket_id):
    """Assign a ticket to a user."""
    data_folder = current_app.config["DATA_FOLDER"]
    
    try:
        assigned_to = request.form.get("assigned_to")
        if not assigned_to:
            flash("User selection is required", "error")
            return redirect(url_for("ticket_bp.manage_tickets"))
        
        success = ticket_processing.assign_ticket(ticket_id, assigned_to, data_folder)
        
        if success:
            flash(f"Ticket {ticket_id} assigned to {assigned_to}", "success")
        else:
            flash(f"Failed to assign ticket {ticket_id}", "error")
            
    except Exception as e:
        logger.error(f"Error assigning ticket {ticket_id}: {e}", exc_info=True)
        flash("Error assigning ticket", "error")
    
    return redirect(url_for("ticket_bp.manage_tickets"))


@ticket_bp.route("/tickets/clear", methods=["POST"])
def clear_ticket():
    """Clear a ticket with a clearance reason."""
    data_folder = current_app.config["DATA_FOLDER"]
    
    try:
        ticket_id = request.form.get("ticket_id")
        cleared_by = request.form.get("cleared_by")
        clearance_reason = request.form.get("clearance_reason")
        
        if not all([ticket_id, cleared_by, clearance_reason]):
            flash("All fields are required for clearing a ticket", "error")
            return redirect(url_for("ticket_bp.manage_tickets"))
        
        success = ticket_processing.clear_ticket(
            ticket_id, cleared_by, clearance_reason, data_folder
        )
        
        if success:
            flash(f"Ticket {ticket_id} cleared and added to suppression list", "success")
        else:
            flash(f"Failed to clear ticket {ticket_id}", "error")
            
    except Exception as e:
        logger.error(f"Error clearing ticket: {e}", exc_info=True)
        flash("Error clearing ticket", "error")
    
    return redirect(url_for("ticket_bp.manage_tickets"))


@ticket_bp.route("/tickets/api/assign/<ticket_id>", methods=["POST"])
def api_assign_ticket(ticket_id):
    """API endpoint for assigning tickets via AJAX."""
    data_folder = current_app.config["DATA_FOLDER"]
    
    try:
        data = request.get_json()
        assigned_to = data.get("assigned_to")
        
        if not assigned_to:
            return jsonify({"success": False, "message": "User selection is required"}), 400
        
        success = ticket_processing.assign_ticket(ticket_id, assigned_to, data_folder)
        
        if success:
            return jsonify({
                "success": True, 
                "message": f"Ticket {ticket_id} assigned to {assigned_to}"
            })
        else:
            return jsonify({
                "success": False, 
                "message": f"Failed to assign ticket {ticket_id}"
            }), 400
            
    except Exception as e:
        logger.error(f"Error in API assign ticket {ticket_id}: {e}", exc_info=True)
        return jsonify({"success": False, "message": "Internal server error"}), 500


@ticket_bp.route("/tickets/api/clear", methods=["POST"])
def api_clear_ticket():
    """API endpoint for clearing tickets via AJAX."""
    data_folder = current_app.config["DATA_FOLDER"]
    
    try:
        data = request.get_json()
        ticket_id = data.get("ticket_id")
        cleared_by = data.get("cleared_by")
        clearance_reason = data.get("clearance_reason")
        raise_issue_flag = data.get("raise_issue", False)
        
        if not all([ticket_id, cleared_by, clearance_reason]):
            return jsonify({
                "success": False, 
                "message": "All fields are required"
            }), 400
        
        success = ticket_processing.clear_ticket(
            ticket_id, cleared_by, clearance_reason, data_folder
        )
        
        if success:
            # Optionally raise an issue
            if raise_issue_flag:
                try:
                    import issue_processing
                    # Load ticket to pull details
                    tdf = ticket_processing.load_tickets(data_folder)
                    ticket_row = tdf[tdf["TicketID"].astype(str) == str(ticket_id)]
                    if not ticket_row.empty:
                        entity_id = ticket_row.iloc[0].get("EntityID", "Unknown")
                        details_desc = ticket_row.iloc[0].get("Details", "")
                    else:
                        entity_id = "Unknown"
                        details_desc = ""
                    _ = issue_processing.add_issue(
                        raised_by=cleared_by,
                        fund_impacted=entity_id,
                        data_source="TicketSystem",
                        issue_date=datetime.now().date(),
                        description=f"Auto-raised from ticket {ticket_id}: {details_desc}",
                        jira_link=None,
                        in_scope_for_go_live="No",
                        data_folder_path=data_folder,
                    )
                except Exception as ie:
                    logger.error(f"Error auto-raising issue for ticket {ticket_id}: {ie}")

            return jsonify({
                "success": True,
                "message": f"Ticket {ticket_id} cleared and added to suppression list"
            })
        else:
            return jsonify({
                "success": False,
                "message": f"Failed to clear ticket {ticket_id}"
            }), 400
            
    except Exception as e:
        logger.error(f"Error in API clear ticket: {e}", exc_info=True)
        return jsonify({"success": False, "message": "Internal server error"}), 500


# --- NEW API endpoint for retest via AJAX ---
@ticket_bp.route("/tickets/api/retest", methods=["POST"])
def api_retest_ticket():
    """API endpoint to mark a ticket for retest (AJAX)."""
    data_folder = current_app.config["DATA_FOLDER"]
    try:
        data = request.get_json()
        ticket_id = data.get("ticket_id")
        if not ticket_id:
            return jsonify({"success": False, "message": "ticket_id required"}), 400

        success = ticket_processing.retest_ticket(ticket_id, data_folder)

        if success:
            return jsonify({"success": True, "message": f"Ticket {ticket_id} reset for retest"})
        else:
            return jsonify({"success": False, "message": f"Failed to reset ticket {ticket_id}"}), 400
    except Exception as e:
        logger.error(f"Error in API retest ticket: {e}", exc_info=True)
        return jsonify({"success": False, "message": "Internal server error"}), 500


@ticket_bp.route("/tickets/stats")
def ticket_stats():
    """API endpoint to get ticket statistics for dashboard."""
    data_folder = current_app.config["DATA_FOLDER"]
    
    try:
        tickets_df = ticket_processing.load_tickets(data_folder)
        
        stats = {
            "unallocated": 0,
            "assigned": 0,
            "cleared": 0,
            "total": 0
        }
        
        if not tickets_df.empty:
            status_counts = tickets_df["Status"].value_counts().to_dict()
            stats["unallocated"] = status_counts.get("Unallocated", 0)
            stats["assigned"] = status_counts.get("Assigned", 0)
            stats["cleared"] = status_counts.get("Cleared", 0)
            stats["total"] = len(tickets_df)
        
        return jsonify(stats)
        
    except Exception as e:
        logger.error(f"Error getting ticket stats: {e}", exc_info=True)
        return jsonify({"error": "Failed to load ticket statistics"}), 500 